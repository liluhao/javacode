



# RabbitMQ 实战教程

# 学习资料

### 中文文档

[Java客户端指南 · RabbitMQ in Chinese (mr-ping.com)](http://rabbitmq.mr-ping.com/ClientDocumentation/java-api-guide.html)

[尚硅谷笔记](https://note.oddfar.com/pages/ee71b9/#幂等性)

### Spring整合入门

[超详细的RabbitMQ入门，看这篇就够了！](https://developer.aliyun.com/article/769883)

[详细讲解！RabbitMQ防止数据丢失](https://mp.weixin.qq.com/s/KGCER3TWLT6Yk_UwsYJZyA)

[rabbitMq基础，springboot整合实现](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw%3D%3D&idx=1&mid=2247485371&scene=21&sn=cbbab6671f28e6069f84110baff40237#wechat_redirect)

[RabbitMQ：@RabbitListener 与 @RabbitHandler 及 消息序列化 - 简书 (jianshu.com)](https://www.jianshu.com/p/911d987b5f11)

### windows系统下操作

https://www.cnblogs.com/lykbk/p/erewererewr32434343.html

### 常用命令

启动： net start RabbitMQ

关闭：net stop RabbitMQ 

重启：net stop RabbitMQ && net start RabbitMQ

### 软件安装

[版本对照](https://www.rabbitmq.com/which-erlang.html)

[尚硅谷笔记](https://note.oddfar.com/pages/ee71b9/#幂等性)

# 编程不良人学习

## 1.MQ引言

### 1.1 什么是MQ

`MQ`(Message Quene) :  翻译为 `消息队列`,通过典型的 `生产者`和`消费者`模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 `消息中间件`	通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。

### 1.2 MQ有哪些

当今市面上有很多主流的消息中间件，如老牌的`ActiveMQ`、`RabbitMQ`，炙手可热的`Kafka`，阿里巴巴自主开发`RocketMQ`等。

### 1.3 不同MQ特点

```markdown
# 1.ActiveMQ
		ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!

# 2.Kafka
		Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，
		追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，
		适合产生大量数据的互联网服务的数据收集业务。

# 3.RocketMQ
		RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起
		源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消
		息推送、日志流式处理、binglog分发等场景。

# 4.RabbitMQ
		RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和
		发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在
		其次。
		
```

> RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。

---

## 2.RabbitMQ 的引言

### 2.1 RabbitMQ 

> 基于`AMQP`协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。

![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210927110003592.png)

`官网`: https://www.rabbitmq.com/



`官方教程`: https://www.rabbitmq.com/#getstarted

```markdown
 # AMQP 协议
 		AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:
```

![image-20200311182438041](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200311182438041.png)

### 2.2 RabbitMQ 的安装

#### 2.2.1 下载

`官网下载地址`: https://www.rabbitmq.com/download.html![image-20190925220115235](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190925220115235.png)

> `最新版本`: 3.7.18

#### 2.2.2 下载的安装包![image-20190925220343521](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190925220343521.png)

> `注意`:这里的安装包是centos7安装的包

#### 2.2.3 安装步骤

```markdown
# 1.将rabbitmq安装包上传到linux系统中
	erlang-22.0.7-1.el7.x86_64.rpm
	rabbitmq-server-3.7.18-1.el7.noarch.rpm

# 2.安装Erlang依赖包
	rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm

# 3.安装RabbitMQ安装包(需要联网)
	yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm
		注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要	
				将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config
# 4.复制配置文件
	cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config

# 5.查看配置文件位置
	ls /etc/rabbitmq/rabbitmq.config

# 6.修改配置文件(参见下图:)
	vim /etc/rabbitmq/rabbitmq.config 
```

![image-20190925222230260](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190925222230260-3836271.png)

将上图中配置文件中红色部分去掉`%%`,以及最后的`,`逗号 修改为下图:

![image-20190925222329200](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190925222329200-3836312.png)

```markdown
# 7.执行如下命令,启动rabbitmq中的插件管理
	rabbitmq-plugins enable rabbitmq_management
	
	出现如下说明:
		Enabling plugins on node rabbit@localhost:
    rabbitmq_management
    The following plugins have been configured:
      rabbitmq_management
      rabbitmq_management_agent
      rabbitmq_web_dispatch
    Applying plugin configuration to rabbit@localhost...
    The following plugins have been enabled:
      rabbitmq_management
      rabbitmq_management_agent
      rabbitmq_web_dispatch

    set 3 plugins.
    Offline change; changes will take effect at broker restart.

# 8.启动RabbitMQ的服务
	systemctl start rabbitmq-server
	systemctl restart rabbitmq-server
	systemctl stop rabbitmq-server
	

# 9.查看服务状态(见下图:)
	systemctl status rabbitmq-server
  ● rabbitmq-server.service - RabbitMQ broker
     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago
   Main PID: 2904 (beam.smp)
     Status: "Initialized"
     CGroup: /system.slice/rabbitmq-server.service
             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -
             MBlmbcs...
             ├─3220 erl_child_setup 32768
             ├─3243 inet_gethost 4
             └─3244 inet_gethost 4
      .........
```

![image-20190925222743776](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190925222743776-3836511.png)

```markdown
# 10.关闭防火墙服务
	systemctl disable firewalld
    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
	systemctl stop firewalld   

# 11.访问web管理界面
	http://10.15.0.8:15672/
```

 ![image-20190926194738708](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190926194738708-3836601.png)

```markdown
# 12.登录管理界面
	username:  guest
	password:  guest
```

![image-20190926194954822](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20190926194954822-3836665.png)

----

## 3. RabiitMQ 配置

### 3.1RabbitMQ 管理命令行

```markdown
# 1.服务启动相关
	systemctl start|restart|stop|status rabbitmq-server

# 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ
	rabbitmqctl  help  可以查看更多命令

# 3.插件管理命令行
	rabbitmq-plugins enable|list|disable 
```

### 3.2 web管理界面介绍

#### 3.2.1 overview概览

![image-20191126162026720](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126162026720.png)

- `connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况`

- `channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。`

- `Exchanges：交换机，用来实现消息的路由`

- `Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。`

  

#### 3.2.2 Admin用户和虚拟主机管理

##### 1. 添加用户

![image-20191126162617280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126162617280.png)

上面的Tags选项，其实是指定用户的角色，可选的有以下几个：

- `超级管理员(administrator)`

  可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。

- `监控者(monitoring)`

  可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)

- `策略制定者(policymaker)`

  可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。

- `普通管理者(management)`

  仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。

- `其他`

  无法登陆管理控制台，通常就是普通的生产者和消费者。

##### 2. 创建虚拟主机

1.需要用到工具 :rabbitmqctl

2.进入rabbitmqctl目录：C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.3.1\sbin

3.建立测试用户

rabbitmqctl  add_user test 123456 ，这样我们就新建了一个可以连到rabbitmq的用户，用户名时test,密码是123456

用 rabbitmqctl list_users 看看有多少个用户了,可以看到有guest和test了吧

4.rabbitmqctl add_vhost命令新建一个virtual host :   rabbitmqctl add_vhost test_host

通过 rabbitmqctl list_vhosts命令看看现在系统有几个vhost

5.我们只是声明了一个vhost，我们还要给它分配访问权限

rabbitmqctl set_permissions -p test_host  test "test-*" ".*" ".*"，如此用户名为test的用户就可以访问vitrual host为test_host的资源了，并且具备读写的权限。

6.可通过网页添加用户，exchange，queue，在queue下找到binding设置key。

```markdown
# 虚拟主机
	为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。
```

 ![image-20191126163023153](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126163023153.png)

##### 3. 绑定虚拟主机和用户

创建好虚拟主机，我们还要给用户添加访问权限：

点击添加好的虚拟主机：

 ![image-20191126163506795](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126163506795.png)

进入虚拟机设置界面:

<img src="https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126163631889.png" alt="image-20191126163631889" style="zoom:200%;" />

-----

## 4.RabbitMQ 的第一个程序

### 4.0 AMQP协议的回顾

![image-20200312140114784](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200312140114784.png)

### 4.1 RabbitMQ支持的消息模型

![image-20191126165434784](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126165434784.png)

![image-20191126165459282](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126165459282.png)



### 4.2 引入依赖

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.7.2</version>
</dependency>
```

### 4.3 第一种模型(直连)

![image-20191126165840602](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126165840602.png)

在上图的模型中，有以下概念：

- P：生产者，也就是要发送消息的程序
- C：消费者：消息的接受者，会一直等待消息到来。
- queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。

##### 1. 开发生产者

```java
  //创建连接工厂
  ConnectionFactory connectionFactory = new ConnectionFactory();
  connectionFactory.setHost("10.15.0.9");
  connectionFactory.setPort(5672);
  connectionFactory.setUsername("ems");
  connectionFactory.setPassword("123");
  connectionFactory.setVirtualHost("/ems");
  Connection connection = connectionFactory.newConnection();
  //创建通道
  Channel channel = connection.createChannel();
  //参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性
  channel.queueDeclare("hello",true,false,false,null);
  channel.basicPublish("","hello", null,"hello rabbitmq".getBytes());
  channel.close();
  connection.close();
```

##### 2. 开发消费者

```java
  //创建连接工厂
  ConnectionFactory connectionFactory = new ConnectionFactory();
  connectionFactory.setHost("10.15.0.9");
  connectionFactory.setPort(5672);
  connectionFactory.setUsername("ems");
  connectionFactory.setPassword("123");
  connectionFactory.setVirtualHost("/ems");
  Connection connection = connectionFactory.newConnection();
  Channel channel = connection.createChannel();
  channel.queueDeclare("hello", true, false, false, null);
  channel.basicConsume("hello",true,new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
      System.out.println(new String(body));
    }
  });
```

##### 3. 参数的说明

```java
  channel.queueDeclare("hello",true,false,false,null);
	'参数1':用来声明通道对应的队列
  '参数2':用来指定是否持久化队列
  '参数3':用来指定是否独占队列
  '参数4':用来指定是否自动删除队列
  '参数5':对队列的额外配置
```

---

### 4.4 第二种模型(work quene)

`Work queues`，也被称为（`Task queues`），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。

![image-20200314221002008](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200314221002008.png)

角色：

- P：生产者：任务的发布者
- C1：消费者-1，领取任务并且完成任务，假设完成速度较慢
- C2：消费者-2：领取任务并完成任务，假设完成速度快

##### 1. 开发生产者

```java
channel.queueDeclare("hello", true, false, false, null);
for (int i = 0; i < 10; i++) {
  channel.basicPublish("", "hello", null, (i+"====>:我是消息").getBytes());
}
```

##### 2.开发消费者-1

```java
channel.queueDeclare("hello",true,false,false,null);
channel.basicConsume("hello",true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者1: "+new String(body));
  }
});
```

##### 3.开发消费者-2

```java
channel.queueDeclare("hello",true,false,false,null);
channel.basicConsume("hello",true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    try {
      Thread.sleep(1000);   //处理消息比较慢 一秒处理一个消息
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    System.out.println("消费者2: "+new String(body));  
  }
});
```

##### 4.测试结果

![image-20200314223242058](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200314223242058.png)

![image-20200314223302207](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200314223302207.png)

> `总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。`

##### 5.消息自动确认机制

> Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We'll also lose all the messages that were dispatched to this particular worker but were not yet handled.
>
> But we don't want to lose any tasks. If a worker dies, we'd like the task to be delivered to another worker.

```java
channel.basicQos(1);//一次只接受一条未确认的消息
//参数2:关闭自动确认消息
channel.basicConsume("hello",false,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者1: "+new String(body));
    channel.basicAck(envelope.getDeliveryTag(),false);//手动确认消息
  }
});
```

- 设置通道一次只能消费一个消息

- 关闭消息的自动确认,开启手动确认消息

  ![image-20200314230412178](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200314230412178.png)

  ![image-20200314230423280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200314230423280.png)

---

### 4.5 第三种模型(fanout) 

`fanout 扇出 也称为广播`

 ![image-20191126213115873](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126213115873.png)

在广播模式下，消息发送流程是这样的：

-  可以有多个消费者
-  每个**消费者有自己的queue**（队列）
-  每个**队列都要绑定到Exchange**（交换机）
-  **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定。
-  交换机把消息发送给绑定过的所有队列
-  队列的消费者都能拿到消息。实现一条消息被多个消费者消费

##### 1. 开发生产者

```java
//声明交换机
channel.exchangeDeclare("logs","fanout");//广播 一条消息多个消费者同时消费
//发布消息
channel.basicPublish("logs","",null,"hello".getBytes());
```

##### 2. 开发消费者-1

```java
//绑定交换机
channel.exchangeDeclare("logs","fanout");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//将临时队列绑定exchange
channel.queueBind(queue,"logs","");
//处理消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者1: "+new String(body));
  }
});
```

##### 3. 开发消费者-2

```java
//绑定交换机
channel.exchangeDeclare("logs","fanout");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//将临时队列绑定exchange
channel.queueBind(queue,"logs","");
//处理消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者2: "+new String(body));
  }
});
```

##### 4.开发消费者-3

```java
//绑定交换机
channel.exchangeDeclare("logs","fanout");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//将临时队列绑定exchange
channel.queueBind(queue,"logs","");
//处理消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者3: "+new String(body));
  }
});
```

##### 5. 测试结果

![image-20200315180653207](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200315180653207.png)

![image-20200315180708489](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200315180708489.png)

![image-20200315180728035](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200315180728035.png)

----

### 4.6 第四种模型(Routing)

#### 4.6.1 Routing 之订阅模型-Direct(直连)

发送的消息可以所有的消费者消费，也可以只让部分消费者进行消费。

`在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。`

 在Direct模型下：

- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）
- 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。
- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息

流程:

错误日志存储磁盘，其他日志不进行磁盘存储。所有日志在控制台打印。C2可以理解为控制台。

![image-20191126220145375](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191126220145375.png)

根据使用场景，将不同的消息发送至指定的队列。

图解：

- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。
- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列
- C1：消费者，其所在队列指定了需要routing key 为 error 的消息
- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息
- 消费者通过创建临时队列来获取队列中的消息。
- 当我们发送没有routing key的消息没有队列接收时，那么也没有消费者可以消费

##### 1. 开发生产者

```java
//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发
channel.exchangeDeclare("logs_direct","direct");
String key = "";
//发布消息
channel.basicPublish("logs_direct",key,null,("指定的route key"+key+"的消息").getBytes());
```

##### 2.开发消费者-1

```java
 //声明交换机
channel.exchangeDeclare("logs_direct","direct");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//绑定队列和交换机
channel.queueBind(queue,"logs_direct","error");
channel.queueBind(queue,"logs_direct","info");
channel.queueBind(queue,"logs_direct","warn");

//消费消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者1: "+new String(body));
  }
});
```

##### 3.开发消费者-2

```java
//声明交换机
channel.exchangeDeclare("logs_direct","direct");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//绑定队列和交换机
channel.queueBind(queue,"logs_direct","error");
//消费消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者2: "+new String(body));
  }
});
```

##### 4.测试生产者发送Route key为error的消息时

 ![image-20210927140840436](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210927140840436.png)

##### 5.测试生产者发送Route key为info的消息时

 ![image-20210927140849339](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210927140849339.png)

6. 问题

虽然直连模型，我们可以向指定路由的队列发送消息，但是当我们需要新增队列发消息时，比如再来一个test类型的日志，也可以发送到队C2，我们此时还得手动添加，不够灵活。可以通过Topic模式来解决。

----



#### 4.6.2 Routing 之订阅模型-Topic

`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！这种模型`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`

![image-20191127121900255](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20191127121900255.png)

``` markdown
# 统配符
		* (star) can substitute for exactly one word.    匹配不多不少恰好1个词
		# (hash) can substitute for zero or more words.  匹配一个或多个词
# 如:
		audit.#    匹配audit.irs.corporate或者 audit.irs 等
    audit.*   只能匹配 audit.irs
```

##### 1.开发生产者

```java
//生命交换机和交换机类型 topic 使用动态路由(通配符方式)
channel.exchangeDeclare("topics","topic");
String routekey = "user.save";//动态路由key
//发布消息
channel.basicPublish("topics",routekey,null,("这是路由中的动态订阅模型,route key: ["+routekey+"]").getBytes());
```

![image-20210917105818196](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917105818196.png)

##### 2.开发消费者-1 

`Routing Key中使用*通配符方式`

```java
 //声明交换机
channel.exchangeDeclare("topics","topic");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//绑定队列与交换机并设置获取交换机中动态路由
channel.queueBind(queue,"topics","user.*");

//消费消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者1: "+new String(body));
  }
});
```

![image-20210917105945851](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917105945851.png)

##### 3.开发消费者-2

`Routing Key中使用#通配符方式`

```java
//声明交换机
channel.exchangeDeclare("topics","topic");
//创建临时队列
String queue = channel.queueDeclare().getQueue();
//绑定队列与交换机并设置获取交换机中动态路由
channel.queueBind(queue,"topics","user.#");

//消费消息
channel.basicConsume(queue,true,new DefaultConsumer(channel){
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
    System.out.println("消费者2: "+new String(body));
  }
});
```

##### 4.测试结果

![image-20210927140942758](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210927140942758.png) ![image-

## 5. SpringBoot中使用RabbitMQ

### 5.0 搭建初始环境

##### 	1. 引入依赖

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

##### 	2. 配置配置文件

```yml
spring:
  application:
    name: springboot_rabbitmq
  rabbitmq:
    host: 10.15.0.9
    port: 5672
    username: ems
    password: 123
    virtual-host: /ems
```

`RabbitTemplate`  用来简化操作     使用时候直接在项目中注入即可使用

### 5.1 第一种hello world模型使用

1. ##### 开发生产者

   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;
   
   @Test
   public void testHello(){
     rabbitTemplate.convertAndSend("hello","hello world");
   }
   ```

2. ##### 开发消费者

   ```java
   @Component
   @RabbitListener(queuesToDeclare = @Queue("hello"))
   public class HelloCustomer {
   
       @RabbitHandler
       public void receive1(String message){
           System.out.println("message = " + message);
       }
   }
   ```

### 5.2 第二种work模型使用

1. ##### 开发生产者

   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;
   
   @Test
   public void testWork(){
     for (int i = 0; i < 10; i++) {
       rabbitTemplate.convertAndSend("work","hello work!");
     }
   }
   ```

2. ##### 开发消费者

   ```java
   @Component
   public class WorkCustomer {
       @RabbitListener(queuesToDeclare = @Queue("work"))
       public void receive1(String message){
           System.out.println("work message1 = " + message);
       }
   
       @RabbitListener(queuesToDeclare = @Queue("work"))
       public void receive2(String message){
           System.out.println("work message2 = " + message);
       }
   }
   ```

   > `说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置`

### 5.3 Fanout 广播模型

1. ##### 开发生产者

   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;
   
   @Test
   public void testFanout() throws InterruptedException {
     rabbitTemplate.convertAndSend("logs","","这是日志广播");
   }
   ```

   

2. ##### 开发消费者

   ```java
   @Component
   public class FanoutCustomer {
   
       @RabbitListener(bindings = @QueueBinding(
               value = @Queue,
               exchange = @Exchange(name="logs",type = "fanout")
       ))
       public void receive1(String message){
           System.out.println("message1 = " + message);
       }
   
       @RabbitListener(bindings = @QueueBinding(
               value = @Queue, //创建临时队列
               exchange = @Exchange(name="logs",type = "fanout")  //绑定交换机类型
       ))
       public void receive2(String message){
           System.out.println("message2 = " + message);
       }
   }
   ```

   

### 5.4 Route 路由模型

1. ##### 开发生产者

   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;
   
   @Test
   public void testDirect(){
     rabbitTemplate.convertAndSend("directs","error","error 的日志信息");
   }
   ```

2. ##### 开发消费者

   ```java
   @Component
   public class DirectCustomer {
   
       @RabbitListener(bindings ={
               @QueueBinding(
                       value = @Queue(),
                       key={"info","error"},
                       exchange = @Exchange(type = "direct",name="directs")
               )})
       public void receive1(String message){
           System.out.println("message1 = " + message);
       }
   
       @RabbitListener(bindings ={
               @QueueBinding(
                       value = @Queue(),
                       key={"error"},
                       exchange = @Exchange(type = "direct",name="directs")
               )})
       public void receive2(String message){
           System.out.println("message2 = " + message);
       }
   }
   
   ```

### 5.5 Topic 订阅模型(动态路由模型)

1. ##### 开发生产者

   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;
   
   //topic
   @Test
   public void testTopic(){
     rabbitTemplate.convertAndSend("topics","user.save.findAll","user.save.findAll 的消息");
   }
   ```

   

2. ##### 开发消费者

   ```java
   @Component
   public class TopCustomer {
       @RabbitListener(bindings = {
               @QueueBinding(
                       value = @Queue,
                       key = {"user.*"},
                       exchange = @Exchange(type = "topic",name = "topics")
               )
       })
       public void receive1(String message){
           System.out.println("message1 = " + message);
       }
   
       @RabbitListener(bindings = {
               @QueueBinding(
                       value = @Queue,
                       key = {"user.#"},
                       exchange = @Exchange(type = "topic",name = "topics")
               )
       })
       public void receive2(String message){
           System.out.println("message2 = " + message);
       }
   }
   ```

   ----

## 6. MQ的应用场景

### 6.1 异步处理

`场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式`

- `串行方式:` 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. 

 ![这里写图片描述](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/SouthEast-4860248.png)

- `并行方式: `将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 

 ![这里写图片描述](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/SouthEast-20191127211112660.png)

- `消息队列:`假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  `消息队列`: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 

  ![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/592892-20190520220249900-1679743651.jpg)

由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。



### 6.2 应用解耦

`场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. `

 ![这里写图片描述](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/SouthEast-20191127211247287.png)

这种做法有一个缺点:

当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 

 ![这里写图片描述](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/SouthEast-20191127211304085.png)

- `订单系统:`用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。

- `库存系统:`订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.

  

### 6.3 流量削峰

 `场景:` 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  

  `作用:` 

​			1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) 

​			2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 

 ![这里写图片描述](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/SouthEast-20191127211341601.png)

1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  

2.秒杀业务根据消息队列中的请求信息，再做后续处理.

-----

## 7. RabbitMQ的集群

### 7.1 集群架构

#### 7.1.1 普通集群(副本集群)

> All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   --摘自官网

`默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问`

1. ##### 架构图

![image-20200320094147471](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320094147471.png)

​	核心解决问题:  `当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份`

2. ##### 集群搭建

   ```markdown
   # 0.集群规划
   	node1: 10.15.0.3  mq1  master 主节点
   	node2: 10.15.0.4  mq2  repl1  副本节点
   	node3: 10.15.0.5  mq3  repl2  副本节点
   
   # 1.克隆三台机器主机名和ip映射
   	vim /etc/hosts加入:
   		 10.15.0.3 mq1
       	10.15.0.4 mq2
       	10.15.0.5 mq3
   	node1: vim /etc/hostname 加入:  mq1
   	node2: vim /etc/hostname 加入:  mq2
   	node3: vim /etc/hostname 加入:  mq3
   
   # 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:
   	scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/
   	scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/
   
   # 3.查看cookie是否一致:
   	node1: cat /var/lib/rabbitmq/.erlang.cookie 
   	node2: cat /var/lib/rabbitmq/.erlang.cookie 
   	node3: cat /var/lib/rabbitmq/.erlang.cookie 
   
   # 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:
   	rabbitmq-server -detached 
   
   # 5.在node2和node3执行加入集群命令:
   	1.关闭       rabbitmqctl stop_app
   	2.加入集群    rabbitmqctl join_cluster rabbit@mq1
   	3.启动服务    rabbitmqctl start_app
   
   # 6.查看集群状态,任意节点执行:
   	rabbitmqctl cluster_status
   
   # 7.如果出现如下显示,集群搭建成功:
   	Cluster status of node rabbit@mq3 ...
   	[{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]},
   	{running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]},
   	{cluster_name,<<"rabbit@mq1">>},
   	{partitions,[]},
   	{alarms,[{rabbit@mq1,[]},{rabbit@mq2,[]},{rabbit@mq3,[]}]}]
   
   # 8.登录管理界面,展示如下状态:
   ```

   ![image-20200320095613586](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320095613586.png)

   ```markdown
   # 9.测试集群在node1上,创建队列
   ```

   ![image-20200320095743935](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320095743935.png)

   ```markdown
   # 10.查看node2和node3节点:
   ```

   ![image-20200320095827688](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320095827688.png)

   ![image-20200320095843370](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320095843370.png)

   ```markdown
   # 11.关闭node1节点,执行如下命令,查看node2和node3:
   	rabbitmqctl stop_app
   ```

   ![image-20200320100000347](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320100000347.png)

   ![image-20200320100010968](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320100010968.png)

   ---

#### 7.1.2 镜像集群

> This guide covers mirroring (queue contents replication) of classic queues  --摘自官网
>
> By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made *mirrored* across multiple nodes. --摘自官网

`镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。`



1. ##### 集群架构图

   ![image-20200320113423235](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20200320113423235.png)

   

2. ##### 配置集群架构

   ```markdown
   # 0.策略说明
   	rabbitmqctl set_policy [-p <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern>  <definition>
   	-p Vhost： 可选参数，针对指定vhost下的queue进行设置
   	Name:     policy的名称
   	Pattern: queue的匹配模式(正则表达式)
   	Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode
              		ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes
                           all：表示在集群中所有的节点上进行镜像
                           exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定
                           nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定
               	 ha-params：ha-mode模式需要用到的参数
                   ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual
                   priority：可选参数，policy的优先级
                   
                    
   # 1.查看当前策略
   	rabbitmqctl list_policies
   
   # 2.添加策略
   	rabbitmqctl set_policy ha-all '^hello' '{"ha-mode":"all","ha-sync-mode":"automatic"}' 
   	说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列
   
   # 3.删除策略
   	rabbitmqctl clear_policy ha-all
   
   # 4.测试集群
   ```

# 尚硅谷学习

## 介绍

### **三大功能**

1. 流量削峰
2. 异步处理
3. 应用解耦

### **七大模式**

1. 简单模式
2. 工作模式
3. 发布订阅模式
4. 路由模式
5. 主题模式
6. 发布确认模式
7. rpc模式

### **四大核心**

1. 生产者
2. 交换机
3. 队列
4. 消费者

一个消息队列可以有多个生产者，消费者，可以有多个交换机，一个交换机有多个队列。

每一个生产者和消费者会与rabbitmq建立连接，一个连接里面有多个信道。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631536018725-c57dc492-3eb5-44ee-a4d3-2034865f172c.png)

## 1.简单模式

发送一条消息，接收一条消息。一对一的关系。当生产者和消费者同时运行时，一边生产一边消费。

**步骤：**

1. 创建连接工厂
2. 创建连接
3. 通过连接创建信道
4. 信道连接rabbitmq
5. 通过信道发送消息
6. 通过信道接收消息
7. 成功/失败接收后，对消息的处理

**依赖：**

```java
    <dependencies>
        <!--rabbitmq 依赖客户端-->
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>5.8.0</version>
        </dependency>
        <!--操作文件流的一个依赖-->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.6</version>
        </dependency>
    </dependencies>
```

**生产者**

```java
public class Producer {
    private final static String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //创建一个连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("127.0.0.1");
        factory.setUsername("admin");
        factory.setPassword("121156");
        //创建新的链接
        Connection connection = factory.newConnection();
        //创建管道
        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭
        Channel channel = connection.createChannel();
        /**
         * 生成一个队列
         * 1.队列名称
         * 2.队列里面的消息是否持久化 默认消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
         * 5.其他参数
         */
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String message = "hello world";
        /**
         * 发送一个消息
         * 1.发送到那个交换机
         * 2.路由的 key 是哪个
         * 3.其他的参数信息
         * 4.发送消息的消息体
         */
        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
        System.out.println("消息发送完毕");

    }

}
```

**消费者**

```java
public class Consumer {
    private final static String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("127.0.0.1");
        factory.setUsername("admin");
        factory.setPassword("121156");
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        //推送的消息如何进行消费的接口回调(推送成功后的回调)
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody());
            System.out.println(message);
        };
        //取消消费的接口回调  如在消费的时候队列被删除掉了
        CancelCallback cancelCallback = (consumerTag) -> {System.out.println("消息消费被中断");
};

        /**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者未成功消费的回调
         * 4.消费者取消消费的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback,cancelCallback);
    }
}
```

## 2.工作模式

一个生产者，多个消费者。消费者采用轮询的形式来进行消费。实现方式和简单模式一样，只是多开了几个消费者，不需要其他配置。

注意：一条消息只能由一条消费者消费。

优势：避免某些消息处理过慢时，导致队列中的消息长时间排队。

![工作队列.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631539824538-4c626550-b4f6-4e32-9629-79828cd798ec.png)

```java
//生产者
public class Task {
    private final static String QUEUE_NAME = "hello";

    public static void main(String[] args) throws Exception {
//        Channel channel = RabbitMqUtils.getChannel();
//        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        try (Channel channel = RabbitMqUtils.getChannel();) {
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //从控制台当中接受信息进行发送
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNext()) {
                String message = scanner.next();
                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
                System.out.println("发送消息完成:" + message);
            }
        }
    }
}


//消费者
public class Work01 {
    private final static String QUEUE_NAME = "hello";
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //推送的消息如何进行消费的接口回调(推送成功后的回调)
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody());
            System.out.println(message);
        };
        //取消消费的接口回调  如在消费的时候队列被删除掉了
        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println("消息消费被中断");
        };
        System.out.println("C2 消费者启动等待消费.................. ");
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}
```

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631541871792-165e6dfd-611f-40c2-bb1d-43feb00f05f5.png)

#### 消息应答

RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。

为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。



##### 自动应答

消息发送后立即被认为已经传送成功。

弊端：

1. 消息发送后，信道关闭，消费者未接收，消息丢失。
2. 消费者接收太多来不及处理，消息挤压，导致内存耗尽。

适用场景：

1. 消费者可以高校并以某种速率能够处理这些消息



**手动应答**

可以**批量**应答并减少网络拥堵

**![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631668627753-fd5d3bae-644d-4592-b7c6-328d70de2ce6.png)**

应答方法：

1. Channel.basicAck(用于肯定确认)   RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 
2. Channel.basicNack(用于否定确认) 
3. Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数  不处理该消息了直接拒绝，可以将其丢弃了



**demo**

```java
public class Task01 {
    private static final String TASK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.nextLine();
            channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes());
            System.out.println("消息发送完毕");
        }
    }
}

public class Work01 {
    private static final String TASK_QUEUE_NAME = "ack_queue";
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //队列名称   是否持久化  该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费    最后一个消费者完成后，是否删除信道
        channel.queueDeclare(TASK_QUEUE_NAME,false,false,false,null);
        DeliverCallback deliverCallback = (consumerTag, delivery)->{
            String message  =new String(delivery.getBody(),"UTF-8");
            System.out.println("消费者一号接收到了消息"+message);
            int minute = 1000*60;
            //睡眠10分钟
            try {
                Thread.sleep(minute*10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //1.消息标记tag   2.false标识只应答接收到的那个传递的的消息   true未应答所有消息包括传过来的那条消息
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
            System.out.println("消费者一号接收到了消息"+message);
        };
        //使用手动应答
        boolean autoAck =false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,consumerTag->{});

    }
}

public class Work02 {
    private static final String TASK_QUEUE_NAME = "ack_queue";
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //队列名称   是否持久化  该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费    最后一个消费者完成后，是否删除信道
        channel.queueDeclare(TASK_QUEUE_NAME,false,false,false,null);
        DeliverCallback deliverCallback = (consumerTag, delivery)->{
            String message  =new String(delivery.getBody(),"UTF-8");
            System.out.println("消费者一号接收到了消息"+message);
            int minute = 1000;
            //睡眠10分钟
            try {
                Thread.sleep(minute*10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //1.消息标记tag   2.false标识只应答接收到的那个传递的的消息   true为应答所有消息包括传过来的那条消息
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
            System.out.println("消费者一号消费了消息"+message);
        };
        //使用手动应答
        boolean autoAck =false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,consumerTag->{});

    }
}
```

分析：

work01和work02都是用手动确定的方式。work01消费数据时间为10分钟，work02为10秒钟。

当数据由生产者发送时，会采用轮询的方式依次发送到work01和work02.因work01消费一条数据时间较长，因此其他进入work01的数据进行长时间排队。而work02的消费数据较快。此时当中断work01时，因为work01中含有许多未消费的数据，因为我们设置了手动提交，所以此时这些分配到work01的数据返回到队列中，排队去work02进行消费，而不会丢失。

#### RabbitMQ持久化

1. 队列持久化
2. 消息持久化

注意：MQ中存在未持久化的队列，那么设置之后的队列持久化时，需要先将之前的删除掉。

**队列持久化**

重启rabbitmq服务后，设置持久化的队列不消失。

```
        boolean durable = true;
        //队列持久化，持久化后重启Rabbitmq服务，队列还存在
        channel.queueDeclare(QUEUE_NAME,durable,false,false,null);
```



![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631588757026-9315ce5f-ccd8-45d8-9355-d0b802cc66e8.png)



D标识该队列持久化。

**消息持久化**

重启rabbitmq服务后，设置持久化的消息不消失。

```
channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
```

添加 MessageProperties.PERSISTENT_TEXT_PLAIN这个参数。



假如我们上传了10条数据，5条持久化了，那么重启服务时只会显示这5条持久化的。

注意：

将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。

**不公平分发**

rabbitmq默认采用轮循的方式分发，假如有两个消费者，一个消费时间长，一个消费时间短，使用轮训分发就会让处理速度较快很大一部分时间处于空闲状态，而慢的一直在干活。但是rabbitmq并不知道这种情况，依然很公平地进行消息分发。

```
        //不公平分发
        int prefetchCount = 1;
        channel.basicQos(prefetchCount);
```

由消费者设置，如果有多个消费者，则每个消费者都设置。

0表示公平，默认。

1表示不公平。遵循能者多劳原则

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631590701824-5374cc1c-9edc-4cba-bf56-d6f35ced2b36.png)

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631591137827-66c872ce-aa3f-452d-9003-6bfcf239fb33.png)

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631591102248-03062738-e9ae-488a-b185-78d5131b8cff.png)

**预取值**

消息由队列经管道传递给消费者。消息的发送是异步的，因此管道上肯定不只有一个消息，另外来自消费者的手动确认本质上也是异步的。因此这里有一个未确定消息的缓存区，限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。**该值定义通道上允许的未确认消息的最大数量**。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理 的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631591591494-dbdc8d30-bf89-4969-a221-a1b32be34455.png)

## 3.发布确认

发布确认是保证消息不丢失的重要环节。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631675739715-417126e8-3841-4955-a729-27e3fa36798c.png)

发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法

```java
        channel.confirmSelect();
```

确认发布的方式

1. 单个确认
2. 批量确认
3. 异步确认

#### 单个确认

发一条，确认一次。同步进行，效率慢。出问题，知道哪一个出了问题。

``` java
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //队列持久化，持久化后重启Rabbitmq服务，队列还存在
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        //开启发布确认
        channel.confirmSelect();
        int messageCount = 100000;
        long begin = System.currentTimeMillis();
        for (int i = 0; i < messageCount; i++) {
            String message = i + "";
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            //服务端返回 false 或超时时间内未返回，生产者可以消息重发
            boolean falg = channel.waitForConfirms();
            if (falg) {
                System.out.println("消息发送成功");
            }
        }
        long end = System.currentTimeMillis();
        System.out.println("发布" + messageCount + "个单独确认消息,耗时" + (end - begin) +
                "ms");
    }
```



#### 批量发布

发一批消息，一起确定。吞吐量提高，发生故障，不知道那一条消息。

发布1000条数据，100条确认一次。

对消息进行编号，编号之后，根据编号获取哪些消息成功，哪些消息失败。

``` java
/**
 * 批量
 */
public static void publishMessageBatch() throws Exception {
    Channel channel = RabbitMqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();
    //批量确认消息大小
    int batchSize = 100;
    //未确认消息个数
    int outstandingMessageCount = 0;
    long begin = System.currentTimeMillis();

    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = i + "";
        channel.basicPublish("", queueName, null, message.getBytes());
        outstandingMessageCount++;
        if (outstandingMessageCount == batchSize) {
            channel.waitForConfirms();
            outstandingMessageCount = 0;
        }
    }
    //为了确保还有剩余没有确认消息 再次确认
    if (outstandingMessageCount > 0) {
        channel.waitForConfirms();
    }
    long end = System.currentTimeMillis();
    System.out.println("发布" + MESSAGE_COUNT + "个批量确认消息,耗时" + (end - begin) + "ms");
}
```



#### 异步发布

复杂，性价比高。消息丢失，能够知道是那一条。

利用回调函数来表达消息可靠性的传递。

收到或未收到消息都会将信息给生产者一个回复。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631676385064-4d152040-a8f8-4b67-af85-50289492839c.png)

发消息之前，需要创建监听器，监听哪些消息成功，哪些消息失败。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631676735916-61c4e8d9-0e73-4ef7-81a3-1a65d82aba31.png)



```java
    public static void sendNotSyncData() throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //队列持久化，持久化后重启Rabbitmq服务，队列还存在
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        //开启发布确认
        channel.confirmSelect();
        //消息确认成功回调函数
        ConfirmCallback ackCallBack=(deliverTag,myltiple)->{
            System.out.println("确认的罅隙编号"+deliverTag);
        };

        //消息确认失败回调函数  参数一：消息编号  参数二：是否是批量确认
        ConfirmCallback nackCallBack=(deliverTag,myltiple)->{
            System.out.println("未确认的罅隙"+deliverTag);
        };
        //参数1：监听哪些消息成功。参数2：监听哪些消息失败。
        channel.addConfirmListener( ackCallBack,  nackCallBack);  //监听为异步的
        int messageCount = 100;
        for (int i = 0; i < messageCount; i++) {
            String message = i + "";
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            //服务端返回 false 或超时时间内未返回，生产者可以消息重发

        }
        long end = System.currentTimeMillis();
        System.out.println("发布" + messageCount + "个单独确认消息,耗时" + (end - begin) +
                "ms");
    }
```



结果：

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631677080639-f3e19bcf-3467-4bf1-8338-868dd11a4d64.png)

我们发现，消息已经发送完毕。因为异步的原因，监听器还在执行。因此，后续的确认消息并不是在发送消息，而是监听器在运行。

#### 如何处理异步未确认的消息

监听器和发送消息是两个线程。

一个线程监听，一个线程发送并打印相应结果。两线程的交互，使用并发连续队列。

比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。

原理：先把一百条消息记录下来，那些确定了，就删除掉，剩余的就是未确定的消息。

1. 记录所有消息。
2. 确定收到消息后，删除已确定消息。

用于记录消息

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631756163536-aa8decd3-7cb5-4dbc-8779-a70647d3f8e6.png)

发送消息进行记录

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631756226788-c7c056fc-f5e9-44f0-8b35-a9defa586d8d.png)

确认收到后删除

步骤：

1. 记录要发送的所有消息
2. 删除已经确定的消息
3. 没有确定的消息进行处理

```java
   public static void sendNotSyncData() throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //队列持久化，持久化后重启Rabbitmq服务，队列还存在
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        //开启发布确认
        channel.confirmSelect();

        ConcurrentSkipListMap<Long,String> outstandingConfirms= new ConcurrentSkipListMap<>();


        //消息确认成功回调函数
        ConfirmCallback ackCallBack=(deliverTag,myltiple)->{
            //删除已经确定的消息
            System.out.println("确认的罅隙编号"+deliverTag);
            //批量确认
            if (myltiple){
                ConcurrentNavigableMap<Long,String> confirmed= outstandingConfirms.headMap(deliverTag);
                confirmed.clear();
            }else {
                outstandingConfirms.remove(deliverTag);
            }
            System.out.println("确认的消息："+deliverTag);
        };

        //消息确认失败回调函数  参数一：消息编号  参数二：是否是批量确认
        ConfirmCallback nackCallBack=(deliverTag,myltiple)->{
            //剩下未确认的消息
            System.out.println("未确认的消息"+deliverTag);
        };
        //参数1：监听哪些消息成功。参数2：监听哪些消息失败。
        channel.addConfirmListener( ackCallBack,  nackCallBack);  //监听为异步的
        int messageCount = 100;
        long begin = System.currentTimeMillis();
        for (int i = 0; i < messageCount; i++) {
            String message = i + "";
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            //1.记录所有要发送的消息
            outstandingConfirms.put(channel.getNextPublishSeqNo(),message;


        }
        long end = System.currentTimeMillis();
        System.out.println("发布" + messageCount + "个单独确认消息,耗时" + (end - begin) +
                "ms");
    }
```







#### 三种发布确认速度对比

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631756653720-e8a6c2fb-10c4-4e33-8013-312ec68eec7d.png)

## 4.交换机

当我们不提供交换机时，我们会使用默认交换机

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631759647152-3a45c85a-c869-46ea-b3f1-54725872a454.png)

之前：一个消息只能被消费一次。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631759523590-cacc53ed-eec9-4b10-a7cd-18459eac1efa.png)



需求：一个消息可以被多个消费者消费

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631759568468-38adf4ad-2d4f-4260-a331-f7532642c4aa.png)

交换机通过绑定多个队列来实现一条消息被多个消费者消费。

#### 概念

RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产

者甚至都不知道这些消息传递传递到了哪些队列中。

生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来

自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消

息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631759815383-49a4c3fe-f3d7-4167-a426-c82b974b41c2.png)

#### 类型

1. direct直接（路由类型）
2. topic主题
3. headers标题
4. fanout扇出（发布订阅类型）
5. 无名类型（默认）

##### 无名类型

之前的代码，我们都使用的是默认的交换机。通过“”进行标识

```java
   channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
参数一：交换机名称
参数二：routingkey  路由的key   无交换机时指队列的名称。如果指定交换机，要写routingkey
```

**临时队列**

没有持久化的队列。

1. 名字随机生成
2. 当消费者断开与队列的链接时，队列自动删除

创建方式：

```java
String  queueName = channel.queueDeclare().getQueue();
```

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631760531237-05221948-d6f6-4e32-beda-35360caa13d9.png)

#### 绑定队列

交换机与队列之间的捆绑关系

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631760674983-63b28ec9-810d-400d-bc35-92ce6ef4558d.png)

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631760691189-2590026c-d5c9-413f-86a9-2aea661758da.png)

## 5.发布订阅（扇出）模式

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631763059001-f4709079-5709-40d5-878c-b857a32d228c.png)

将接收到的所有消息广播到它知道的所有队列中（qq群发通知）

扇出交换机绑定的队列的key都一样，所以一个通知发送多个队列。routingkey可以直接忽略。

需要测试：即使不一样，是扇出模式，那么也是多个队列接收消息

![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631760910698-7f7fee4d-b1e0-4f97-9f57-806307d521d3.png)

**实战**

**![image.png](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/1631760935538-496e2c05-eaca-4042-aa20-7b3ad74fb4e9.png)**

**交换机与消费者绑定**

1. 创建链接
2. 创建信道
3. 信道绑定交换机和交换机类型
4. 创建临时队列
5. 将队列和交换机绑定
6. 接收消息。成功回调和失败回调

**交换机与生产者绑定**

1. 创建链接
2. 创建信道
3. 信道绑定交换机和交换机类型
4. 信道向交换机发送消息

### 常见单词

durable：持久化

exclusive：独有的，排外的

arguments：参数

Features：特征

broker：经纪人，中间人

ack：命令正确应答

unacked：为包装的

priority：优先级

## 8.常见队列

### 8.1死信队列

#### 概念

死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。

**应用场景**:

1. 为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.等消费者恢复时，再进行消费。

2. 还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。死信可以在指定的时间内做一些事情，如在指定的时间内被消费。

这些有问题的信息都可以放入死信队列，进行后续处理。

想法：用户订单付款为20分钟，时间到后，用户未付款的话将消息放入死信队列。之后我可以查看死信队列里面的已过期订单的日期，再次向用户推荐相关的物品。

#### 死信的3大来源

1. 消息 TTL 过期（消息10s后过期，过期后入死信队列） 

2. 队列达到最大长度(队列满了，无法再添加数据到 mq 中) 

3. 消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.

#### 死信实战

##### 架构图

![image-20210917111829136](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917111829136.png)

正常情况：c1消费

死信情况：c2消费

##### 生产者

创建流程：

1. 创建交换机
2. 向交换机发送消息，并设置消息的过期时间为10s

```java
public class Producer {
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        channel.exchangeDeclare(Cusumer1.NORMAL_QUEUE, BuiltinExchangeType.DIRECT);
        //设置消息的 TTL 时间  10s
        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();
        for (int i = 0; i < 10; i++) {
            channel.basicPublish(Cusumer1.NORMAL_QUEUE, "zhangsan", properties, String.valueOf(i).getBytes());
            System.out.println("生产者发送消息:" + i);
        }

    }
}
```



![image-20210917145703535](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917145703535.png)

##### 消费者01

创建流程：

1. 创建正常交换机
2. 创建死信交换机
3. 创建死信队列
4. 将死信队列与死信交换机绑定
5. 创建正常队列，并将正常队列与死信队列绑定
6. 将正常交换机与正常队列绑定

``` java
public class Cusumer1 {
    public static String NORMAL_QUEUE = "normal_exchange";
    public static String DEAD_QUEUE = "dead_exchange";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //声明死信和普通交换机 类型为 direct
        channel.exchangeDeclare(Cusumer1.NORMAL_QUEUE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(Cusumer1.DEAD_QUEUE, BuiltinExchangeType.DIRECT);


        //声明死信队列
        String deadQueue = "dead-queue";
        channel.queueDeclare(deadQueue, false, false, false, null);
        //死信队列绑定死信交换机与 routingkey
        channel.queueBind(deadQueue, DEAD_QUEUE, "lisi");

        //正常队列绑定死信队列
        Map<String,Object> params = new HashMap<>();
        //死信队列的交换机。key固定
        params.put("x-dead-letter-exchange",DEAD_QUEUE);
        //死信队列交换机绑定的routingkey
        params.put("x-dead-letter-routing-key","lisi");
        //设置消息的过期时间，在此设置时间后，超过时间未被消费的消息将被清除。(这里设置的话会固定死，通常在生产者设置)
        //以ms为单位
//        params.put("x-message-ttl",10000);
        String normalQueue="normal-queue";
        //创建正常队列并绑定死信交换机
        channel.queueDeclare(normalQueue,false,false,false,params);
        //将正常队列与交换机绑定
        channel.queueBind(normalQueue, NORMAL_QUEUE, "zhangsan");
        
        //成功接收消息的回调
        DeliverCallback deliverCallback = (consumerTag, delivery) ->
        {String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("Consumer01 接收到消息"+message);
        };
        channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {
        });
    }

}

```

![image-20210917144608079](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917144608079.png)

![image-20210917144612934](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917144612934.png)

![image-20210917144628462](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917144628462.png)



![image-20210917144633856](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917144633856.png)

##### 消费者02

``` java
public class Cusumer2 {
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        channel.exchangeDeclare(Cusumer1.DEAD_QUEUE, BuiltinExchangeType.DIRECT);
        String deadQueue = "dead-queue";
        channel.queueDeclare(deadQueue, false, false, false, null);
        channel.queueBind(deadQueue, Cusumer1.DEAD_QUEUE, "lisi");
        System.out.println("等待接收死信队列消息........... ");
        DeliverCallback deliverCallback = (consumerTag, delivery) ->
        {String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("Consumer02 接收死信队列的消息" + message);
        };
        channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> {
        });

    }
}

```

![image-20210917145947877](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917145947877.png)



##### 队列达到最大长度（上方消费者01基础上改变）

上方代码展示的是将过期的消息放入队列，接下来展示当队列满时，新增的消息入死信队列。

设置绑定死信队列时的参数

```java
params.put("x-max-length",6);
```

![image-20210917150945121](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917150945121.png)

##### 消息被拒

手动接收消息，设置消息条件，不符合条件的消息不进行接收。

```java
public class Cusumer1 {
    public static String NORMAL_QUEUE = "normal_exchange";
    public static String DEAD_QUEUE = "dead_exchange";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //声明死信和普通交换机 类型为 direct
        channel.exchangeDeclare(Cusumer1.NORMAL_QUEUE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(Cusumer1.DEAD_QUEUE, BuiltinExchangeType.DIRECT);


        //声明死信队列
        String deadQueue = "dead-queue";
        channel.queueDeclare(deadQueue, false, false, false, null);
        //死信队列绑定死信交换机与 routingkey
        channel.queueBind(deadQueue, DEAD_QUEUE, "lisi");




        //正常队列绑定死信队列
        Map<String,Object> params = new HashMap<>();
        //死信队列的交换机。key固定
        params.put("x-dead-letter-exchange",DEAD_QUEUE);
        //死信队列交换机绑定的routingkey
        params.put("x-dead-letter-routing-key","lisi");
        //设置消息的过期时间，在此设置时间后，超过时间未被消费的消息将被清除。(这里设置的话会固定死，通常在生产者设置)
        //以ms为单位
//        params.put("x-message-ttl",10000);
//        params.put("x-max-length",6);
        String normalQueue="normal-queue";
        //创建正常队列并绑定死信交换机
        channel.queueDeclare(normalQueue,false,false,false,params);
        //将正常队列与交换机绑定
        channel.queueBind(normalQueue, NORMAL_QUEUE, "zhangsan");

        //成功接收消息的回调
        DeliverCallback deliverCallback = (consumerTag, delivery) ->
        {String message = new String(delivery.getBody(), "UTF-8");
        if (message.equals("1")||message.equals("5")){
            System.out.println("Consumer01 接收到消息"+message);
            //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
        }else {
            System.out.println("Consumer01 拒绝接收到消息"+message);
            channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);
        }

        };
        //手动接收消息
        boolean autoAck=false;
        channel.basicConsume(normalQueue, autoAck, deliverCallback, consumerTag -> {
        });
    }

}
```





![image-20210917151851736](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917151851736.png)

### 8.2延迟队列

![image-20210917153705223](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917153705223.png)

延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。

延迟队列是基于死信队列的。

#### 使用场景

1. 订单在十分钟之内未支付则自动取消 

2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 
3. 用户注册成功后，如果三天内没有登陆则进行短信提醒。 
4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员。 
5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议

这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。

![image-20210917152725369](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917152725369.png)

#### RabbitMq中的TTL

TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间。

单位是毫秒。

如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这 条消息如果在TTL 设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。

#### 实战



![image-20210918101643671](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918101643671.png)

##### 步骤：

1. 引入rabbitmq依赖
2. 通过yml设置rabbitmq链接
3. 创建配置类，里面用于创建交换机和队列，并进行绑定
4. 在controller层接收前端传递的消息，并向指定的交换机发送。
5. 创建消费者，监听队列中的消息。

##### 依赖

```java
 
        <!--rabbitmq-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: admin
    password: 121156
        
  

```

##### 队列和交换机配置类

```java
@Configuration
public class TclQueueConfig {
    public static final String X_EXCHANGE = "X";
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
    public static final String DEAD_LETTER_QUEUE = "QD";

    // 声明 xExchange
    @Bean("xExchange")
    public DirectExchange xExchange() {
        return new DirectExchange(X_EXCHANGE);
    }

    // 声明 yExchange
    @Bean("yExchange")
    public DirectExchange yExchange() {
        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
    }
//声明队列 A ttl 为 10s 并绑定到对应的死信交换机


    @Bean("queueA")
    public Queue queueA() {
        Map<String, Object> args = new HashMap<>(3);
//声明当前队列绑定的死信交换机
        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
//声明当前队列的死信路由 key
        args.put("x-dead-letter-routing-key", "YD");
//声明队列的 TTL
        args.put("x-message-ttl", 10000);
        //druable 持久化  后面输入队列的名称
        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();
    }

    // 声明队列 A 绑定 X 交换机
    @Bean
    public Binding queueaBindingX(@Qualifier("queueA") Queue queueA,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        return BindingBuilder.bind(queueA).to(xExchange).with("XA");
    }

    //声明队列 B ttl 为 40s 并绑定到对应的死信交换机
    @Bean("queueB")
    public Queue queueB() {
        Map<String, Object> args = new HashMap<>(3);
//声明当前队列绑定的死信交换机
        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
//声明当前队列的死信路由 key
        args.put("x-dead-letter-routing-key", "YD");
//声明队列的 TTL
        args.put("x-message-ttl", 40000);
        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();
    }

    //声明队列 B 绑定 X 交换机
    @Bean
    public Binding queuebBindingX(@Qualifier("queueB") Queue queue1B,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        return BindingBuilder.bind(queue1B).to(xExchange).with("XB");
    }

    //声明死信队列 QD
    @Bean("queueD")
    public Queue queueD() {
        return new Queue(DEAD_LETTER_QUEUE);
    }

    //声明死信队列 QD 绑定关系
    @Bean
    public Binding deadLetterBindingQAD(@Qualifier("queueD") Queue queueD,
                                        @Qualifier("yExchange") DirectExchange yExchange) {
        return BindingBuilder.bind(queueD).to(yExchange).with("YD");


    }
}
```



##### 发送消息

```java
@RestController
@Slf4j
@RequestMapping("/api/rabbitmq")
public class TclQueueController {

    @Autowired
    public RabbitTemplate rabbitTemplate;

    @GetMapping("/sendMeg/{message}")
    public void sendMeg(@PathVariable String message) {
        log.info("当前时间：{},发送一条信息给两个 TTL 队列:{}", new Date(), message);
        rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: "+message);
        rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: "+message);

    }

}
```



##### 创建消费者

```java
@Slf4j
@Component
public class DeadLetterQueueConsumer {
    //创建消费者监听，监听QD队列的消息
    @RabbitListener(queues = "QD")
    public void receiveD(Message message, Channel channel){
            String msg = new String(message.getBody());
        log.info("当前时间：{},收到死信队列信息{}", new Date().toString(), msg);
    }
}

```

#### 实战问题1：发送不同时间到期的消息，都需要创建新的队列

每次想发送不同时间到期的消息，都需要创建新的队列。

![image-20210918111228121](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918111228121.png)

**解决问题**

流程：

1. 创建新的队列，不设置队列内消息的过期时间
2. 将新的队列与死信队列进行绑定。
3. 将交换机与新队列进行绑定。
4. 发送消息时，设置消息的TTl时间

**创建新的队列**

```java
    @Bean("queueC")
    public Queue QueueC() {
        Map<String, Object> args = new HashMap<>(3);
//声明当前队列绑定的死信交换机
        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
//声明当前队列的死信路由 key
        args.put("x-dead-letter-routing-key", "YD");
        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();
    }
```

**生产者**

```java
    @GetMapping("/sendExpirationMsg//{message}/{ttlTime}")
    public void sendMegHasTTl(@PathVariable String message, @PathVariable String ttlTime) {

        rabbitTemplate.convertAndSend("X", "XC", message, msg -> {
            msg.getMessageProperties().setExpiration(ttlTime);
            return msg;
        });
        log.info("当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}", new Date(), ttlTime, message);
    }
```

**效果**

发送消息：

```java
http://localhost:8000/api/rabbitmq/sendExpirationMsg/zhq1/10000
http://localhost:8000/api/rabbitmq/sendExpirationMsg/zhq2/1000
```

![image-20210918114030653](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918114030653.png)

延迟消息会进行排队。

如果第一条消息10s过期，第二天消息2s过期，进入死信队列时，是排队进入的，就会造成过了20s后，第一条消息进入后，第二条消息才进入。

看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。

#### 实战问题2：进入死信队列的顺序并不是谁先到期谁先进

如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间 及时死亡，就无法设计成一个通用的延时队列

**解决问题：**

rabbitmq为我们提供了死信队列的插件，我们安装此插件后，设置交换机的类型为死信消息，即可实现先到期的消息，先入死信队列的情况。

安装该插件后会生成新的Exchange类型`x-delayed-message`，该类型消息支持延迟投递机制,接收到消息后并未立即将消息投递至目标队列中，而是存储在`mnesia`(一个分布式数据系统)表中，检测消息延迟时间（通过消息头的x-delay指定），如达到可投递时间时并将其通过`x-delayed-type`类型标记的交换机类型投递至目标队列。

##### 死信插件安装

**安装步骤：**

1. 去网站下载插件。

[Releases · rabbitmq/rabbitmq-delayed-message-exchange · GitHub](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases)

![image-20210918141625725](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918141625725.png)

2. 将插件放在rabbitmq的plus文件夹下。再执行命令：

```reStructuredText
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```

3. 效果：

交换机类型多了一个死信消息。

![image-20210918141808100](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918141808100.png)



##### 代码实现

1. **代码架构图**

![image-20210918142150044](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918142150044.png)

自定义交换机（CustomExchange）：可以支持延迟投递机制。（消息传递后并不会立即投递到目标队列中），而是存储在mnesia（分布式数据系统）表中，当到达投递时间后，才投递到目标队列中。

**2. 流程：**

1. 创建支持延迟投递的自定义交换机。CustomExchange
2. 创建自定义交换机的死信队列
3. 将自定义交换机与死信队列绑定。
4. 创建新的消费者
5. 生产者发送消息

**创建延迟交换机和队列**

```java
@Configuration
public class DelayedQueueConfig {
    public static final String DELAYED_QUEUE_NAME = "delayed.queue";
    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";
    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";

    @Bean
    public Queue delayedQueue() {
        return new Queue(DELAYED_QUEUE_NAME);
    }
    @Bean
    public CustomExchange delayedExchange() {
        Map<String, Object> arguments = new HashMap<>();
//设置自定义交换机的类型。
        arguments.put("x-delayed-type", "direct");
        //1.交换机名称
        //2.交换机的类型
        //3.是否需要持久化
        //4.是否需要自动删除
        //5.其他参数
        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);
    }

    @Bean
    public Binding bindingDelayedQueue(@Qualifier("delayedQueue") Queue queue,
                                       @Qualifier("delayedExchange") CustomExchange
                                               delayedExchange) {
        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();
    }

}
```

**消费者**

```java
@RabbitListener(queues = DELAYED_QUEUE_NAME)
public void receiveDelayedQueue(Message message) {
    String msg = new String(message.getBody());
    log.info("当前时间：{},收到延时队列的消息：{}", new Date().toString(), msg);
}
```

**生产者**

```java
@GetMapping("sendDelayMsg/{message}/{delayTime}")
public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {
    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,
            correlationData -> {
                //设置消息的过期时间
                correlationData.getMessageProperties().setDelay(delayTime);
                return correlationData;
            });
    log.info(" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}", new
            Date(), delayTime, message);
}
```

**效果**

``` java
http://localhost:8000/api/rabbitmq/sendDelayMsg/zhq1/30000
http://localhost:8000/api/rabbitmq/sendDelayMsg/zhq2/3000
```

![image-20210918144955605](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918144955605.png)

第二条消息先被消费掉了，符合预期。

#### 问题

- 会降低性能，所以如果没有该需求，则不要使用。
- 该插件不适合大数据量的延时消息，比如百万或一亿。
- 延时时长：0<=n<=(2^32)-1 ，单位毫秒。约49天左右。
- 如果延时时长设置超过最大时长时即49天，则会直接被消费，并不会等消息过期消费。

### 延迟队列常用实现

[延时队列常用实现详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/df09f1e7b05f)

### 总结

虽然死信在做延迟队列时，有一定的问题。但是死信队列至少保证消息被消费一次或者未被消费的消息进入队列中。



## 9.发布确认高级

在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢

**所有服务正常情况下**

![image-20210918150336986](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918150336986.png)

**服务异常情况下**

当我们向交换机发送消息时，如果交换机挂掉，或者队列挂掉，那么这些消息就会进行丢失。并且生产者得不到消息的回应，并不能知道哪些消息丢失了。

此时，我们需要一个缓存机制，将生产者发送的消息进行缓存，当这些消息进入到交换机或者队列中，确保消息未丢失后，再去清除这些缓存。

![image-20210918150620841](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918150620841.png)



#### 正常情况下消息处理流程

1. 创建交换机和队列，并将二者进行绑定
2. 生产者向指定交换机发送消息
3. 消费者接收指定队列的消息

#### 异常情况下消息处理流程

1. 创建交换机和队列，并将二者进行绑定
2. 设置消费者
3. 修改配置文件，支持消息接收的回调
4. 设置生产者，并将当前消息id。（回调时需要获取）
5. 设置交换机接消息情况的回调（通过实现RabbitTemplate的ConfirmCallBack接口）
   1. 成功接收：处理
   2. 未成功接收：处理

#### 交换机发生异常

##### 配置文件

​    publisher-confirm-type: correlated 设置

```yml
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: admin
    password: 121156
    publisher-confirm-type: correlated
    # 开启交换机接收消息失败的回调
    # none:禁用发布确认模式，默认值
    # correlated:发布消息成功到交换机后触发的方法
    # simple ：1.和correlated效果相同。2.一条消息一条消息接收，只有之前的消息接收成功后，才接受之后的消息
    publisher-returns: true
    # 队列未接收到消息的回调
```



##### 交换机和队列

```java
@Configuration
public class ConfirmQueueConfig {
    public static final String EXCHANGE_NAME = "confirm-exchange-1";
    public static final String QUEUE_NAME = "confirm-queue-1";
    public static final String ROUTING_KEY = "confirm-routingkey-1";


    @Bean("confirmExchange")
    public DirectExchange exchange1() {
        return new DirectExchange(EXCHANGE_NAME);
    }

    @Bean("confirmQueue")
    public Queue queue1() {
        return new Queue(QUEUE_NAME);
    }

    @Bean
    public Binding bindExchange1ToQueue1(@Qualifier("confirmExchange") DirectExchange directExchange, @Qualifier("confirmQueue") Queue queue) {
        return BindingBuilder.bind(queue).to(directExchange).with(ROUTING_KEY);
    }


}

```

##### 生产者和消费者

```java
//生产者


    @Autowired
    public RabbitTemplate rabbitTemplate;

    @GetMapping("sendConfirmMsg/{message}")
    public void sendConfirmMsg(@PathVariable String message) {
        //指定消息 id 为 1
        CorrelationData correlationData1 = new CorrelationData("1");
        String routingKey = ConfirmQueueConfig.ROUTING_KEY;
        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_NAME, routingKey, message,correlationData1);
        log.info("发布一条：{}进入发布确认高级队列：{}", message, ConfirmQueueConfig.EXCHANGE_NAME);
    }


//消费者

@Configuration
@Slf4j
public class ConfirmQueueConsumer {
    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_NAME)
    public void receiveConfirmQueue(Message message) {
        String msg = new String(message.getBody());
        log.info("当前时间：{},收到发布确认队列的消息：{}", new Date().toString(), msg);
    }
}
```



##### 回调接口

当生产者向交换机发送消息发送不过去时，就会调用回调接口。

```java
@Component
@Slf4j
public class MyCallBack implements RabbitTemplate.ConfirmCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;


    //将创建的消息接收的回调对象添加到rabbitTemplate中。
    @PostConstruct
    public  void init(){
        rabbitTemplate.setConfirmCallback(this);
    }

    /**
     * 交换机确定是否收到消息的回调方法
     * 1.发消息  交换机成功接受到了  回调
     * 1.1CorrelationData保存回调消息的ID及相关信息
     * 1.2交换机收到消息   ack：true
     * 1.3cause 失败的原因  cause：null
     * 2.发消息  交换机没有成功接收   回调
     * 2.1CorrelationData保存回调消息的ID及相关信息
     * 2.2交换机收到消息   ack：false
     * 2.3 cause：失败的原因
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        System.out.println(correlationData);
        String id = correlationData == null ? "" : correlationData.getId();
        if (ack) {
            log.info("交换机已经收到 id 为:{}的消息", id);
        } else {
            log.info("交换机还未收到 id 为:{}消息,由于原因:{}", id, cause);
        }

    }
}

```

注意：

![image-20210918153053077](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918153053077.png)

##### 结果

**向指定的交换机发送消息：成功回调**

```java
http://localhost:8000/api/rabbitmq/config/sendConfirmMsg/zhq1
```

![image-20210918174137528](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918174137528.png)

**当我们向一个不存在的交换机发送消息时：失败回调**

![image-20210918174430738](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918174430738.png)

报错：交换机不存在

**当我们向一个不存在的队列发送消息时：成功回调**

![image-20210918174658479](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918174658479.png)

此时我们发现，虽然发送了成功的回调，但是因为我们向不存在的队列中发送了消息，因此此消息在交换机向队列发送时产生了丢失。

#### 队列发生异常（消息回退）

在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。

如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。

流程：

1. 设置Mandatory参数
2. 其他步骤和之前一样。

##### 配置文件

​    publisher-returns: true 开启未接收到消息的回调

```yml
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: admin
    password: 121156
    publisher-confirm-type: correlated
    # 开启交换机接收消息失败的回调
    # none:禁用发布确认模式，默认值
    # correlated:发布消息成功到交换机后触发的方法
    # simple ：1.和correlated效果相同。2.一条消息一条消息接收，只有之前的消息接收成功后，才接受之后的消息
    publisher-returns: true
    # 队列未接收到消息的回调
```



##### 交换机和队列

和上方一样

##### 生产者和消费者

``` java
//生产者
@RestController
@Slf4j
@RequestMapping("/api/rabbitmq/config")
public class ConfirmQueueController {

    @Autowired
    public RabbitTemplate rabbitTemplate;

    @GetMapping("sendConfirmMsg3/{message}")
    public void sendConfirmMsg3(@PathVariable String message) {
        //指定消息 id 为 1
        String routingKey = ConfirmQueueConfig.ROUTING_KEY;
        //指向一个不存在的队列。
        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_NAME, routingKey+1, message,new CorrelationData(UUID.randomUUID().toString()));
        log.info("发布一条：{}进入发布确认高级队列：{}", message, ConfirmQueueConfig.EXCHANGE_NAME);
    }



}
```

##### 回调函数

```java
@Component
@Slf4j
public class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;


    //将创建的消息接收的回调对象添加到rabbitTemplate中。
    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setMandatory(true);
        rabbitTemplate.setReturnCallback(this);
    }

    /**
     * 交换机确定是否收到消息的回调方法
     * 1.发消息  交换机成功接受到了  回调
     * 1.1CorrelationData保存回调消息的ID及相关信息
     * 1.2交换机收到消息   ack：true
     * 1.3cause 失败的原因  cause：null
     * 2.发消息  交换机没有成功接收   回调
     * 2.1CorrelationData保存回调消息的ID及相关信息
     * 2.2交换机收到消息   ack：false
     * 2.3 cause：失败的原因
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        System.out.println(correlationData);
        String id = correlationData == null ? "" : correlationData.getId();
        if (ack) {
            log.info("交换机已经收到 id 为:{}的消息", id);
        } else {
            log.info("交换机还未收到 id 为:{}消息,由于原因:{}", id, cause);
        }

    }

    //当消息无法路由的时候的回调方法
    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String
            exchange, String routingKey) {
        log.error(" 消 息 {}, 被 交 换 机 {} 退 回 ， 退 回 原 因 :{}, 路 由 key:{}", new
                String(message.getBody()), exchange, replyText, routingKey);
    }
}

```

##### 结果

```java
http://localhost:8000/api/rabbitmq/config/sendConfirmMsg3/zhq1
```

![image-20210918181400196](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918181400196.png)

#### 备份交换机

有了 mandatory 参数，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。

而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？

前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。

不要慌，在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。

什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会将这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。

![image-20210918203040118](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918203040118.png)

流程：

1. 创建普通交换机和队列
2. 创建备份交换机，并让备份交换机绑定普通交换机
3. 创建备份队列和警告队列
4. 备份交换机和警告队列与备份队列绑定

注意：

备份队列用于消费者消费，警告队列用于报警，日志打印那条消息有问题。

备份交换机采用fanout类型，目的使所有与他绑定的队列都接收到相同的消息。

##### 创建交换机和队列

将普通交换机与备份交换机连接

``` java
ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).withArgument("alternate-exchange", BACKUP_EXCHANGE).build();
```

```java
@Configuration
public class ConfirmQueueConfig {
    public static final String EXCHANGE_NAME = "confirm-exchange-1";
    public static final String QUEUE_NAME = "confirm-queue-1";
    public static final String ROUTING_KEY = "confirm-routingkey-1";

    //备份交换机和备份队列
    public static final String BACKUP_EXCHANGE = "backup_exchange";
    public static final String BACKUP_QUEUE = "backup_queue";
    //警告队列
    public static final String WARN_QUEUE = "warn_queue";


    @Bean("confirmExchange")
    public DirectExchange exchange1() {
        //普通交换机绑定备份交换机
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).withArgument("alternate-exchange", BACKUP_EXCHANGE).build();
    }

    @Bean("confirmQueue")
    public Queue queue1() {
        return new Queue(QUEUE_NAME);
    }
    //普通交换机绑定普通队列
    @Bean
    public Binding bindExchange1ToQueue1(@Qualifier("confirmExchange") DirectExchange directExchange, @Qualifier("confirmQueue") Queue queue) {
        return BindingBuilder.bind(queue).to(directExchange).with(ROUTING_KEY);
    }



    @Bean("backupExchange")
    public FanoutExchange backupExchange() {
        return ExchangeBuilder.fanoutExchange(BACKUP_EXCHANGE).durable(true).build();
    }


    //备份队列：用于消息消费
    @Bean("backupQueue")
    public Queue backUpQueue() {
        return new Queue(BACKUP_QUEUE);
    }
    //警告队列：用于消息丢失的警告
    @Bean("warnQueue")
    public Queue warnQueue() {
        return new Queue(WARN_QUEUE);
    }



    //警告队列绑定备份交换机
    @Bean
    public Binding bindWarnQueueBackupExchange(@Qualifier("backupExchange") FanoutExchange fanoutExchange, @Qualifier("warnQueue") Queue queue) {
        return BindingBuilder.bind(queue).to(fanoutExchange);
    }

    //备份队列绑定备份交换机
    @Bean
    public Binding bindBackupQueueBackupExchange(@Qualifier("backupExchange") FanoutExchange fanoutExchange, @Qualifier("backupQueue") Queue queue) {
        return BindingBuilder.bind(queue).to(fanoutExchange);
    }

}
```

##### 创建消费者

```java
@Configuration
@Slf4j
public class ConfirmQueueConsumer {
    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_NAME)
    public void receiveConfirmQueue(Message message) {
        String msg = new String(message.getBody());
        log.info("当前时间：{},收到发布确认队列的消息：{}", new Date().toString(), msg);
    }

        //备份消费者
    @RabbitListener(queues = ConfirmQueueConfig.BACKUP_QUEUE)
    public void backUpConfirmQueue(Message message) {
        String msg = new String(message.getBody());
        log.info("当前时间：{},收到备份队列的消息：{}", new Date().toString(), msg);
    }
    

    //报警消费者：用于报警
    @RabbitListener(queues = ConfirmQueueConfig.WARN_QUEUE)
    public void warnConfirmQueue(Message message) {
        String msg = new String(message.getBody());
        log.error("报警发现不可路由消息：{}", msg);
    }
}

```

##### 创建生产者

```java
    @GetMapping("sendConfirmMsg3/{message}")
    public void sendConfirmMsg3(@PathVariable String message) {
        //指定消息 id 为 1
        String routingKey = ConfirmQueueConfig.ROUTING_KEY;
        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_NAME, routingKey, message,new CorrelationData(UUID.randomUUID().toString()));
        log.info("发布一条：{}进入发布确认高级队列：{}", message, ConfirmQueueConfig.EXCHANGE_NAME);
    }

```

##### 回调

我们此时还添加了接收消息的回调和消息接收失败的回调

``` java
@Component
@Slf4j
public class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;


    //将创建的消息接收的回调对象添加到rabbitTemplate中。
    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setMandatory(true);
        rabbitTemplate.setReturnCallback(this);
    }

    /**
     * 交换机确定是否收到消息的回调方法
     * 1.发消息  交换机成功接受到了  回调
     * 1.1CorrelationData保存回调消息的ID及相关信息
     * 1.2交换机收到消息   ack：true
     * 1.3cause 失败的原因  cause：null
     * 2.发消息  交换机没有成功接收   回调
     * 2.1CorrelationData保存回调消息的ID及相关信息
     * 2.2交换机收到消息   ack：false
     * 2.3 cause：失败的原因
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        System.out.println(correlationData);
        String id = correlationData == null ? "" : correlationData.getId();
        if (ack) {
            log.info("交换机已经收到 id 为:{}的消息", id);
        } else {
            log.info("交换机还未收到 id 为:{}消息,由于原因:{}", id, cause);
        }

    }

    //当消息无法路由的时候的回调方法
    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String
            exchange, String routingKey) {
        log.error(" 消 息 {}, 被 交 换 机 {} 退 回 ， 退 回 原 因 :{}, 路 由 key:{}", new
                String(message.getBody()), exchange, replyText, routingKey);
    }
}
```

**结果**

```java
http://localhost:8000/api/rabbitmq/config/sendConfirmMsg3/zhq1
```

正常情况

![image-20210918212212541](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918212212541.png)

发送到一个不存在的队列

![image-20210918220043784](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918220043784.png)

我们将mandatory和备份交换机一起使用

mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是备份交换机优先级高。

我们知道，备份交换机也只是交换机，也可能存在挂掉的情况。备份交换机只是帮我们进一步降低了消息丢失，但是也并不是100%保证。

###### 备份交换机出现异常

我们将普通交换机和一个不存在的交换机进行绑定

注意：BACKUP_EXCHANGE+1这个交换机不存在

``` java
    @Bean("confirmExchange")
    public DirectExchange exchange1() {
        //普通交换机绑定备份交换机
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).withArgument("alternate-exchange", BACKUP_EXCHANGE+1).build();
    }

```

结果：

``` java
http://localhost:8000/api/rabbitmq/config/sendConfirmMsg3/zhq1
```

![image-20210918220629023](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918220629023.png)

此时我们发现，当普通交换机绑定不存在的队列，并且备份交换机出现问题时，此时会走mandatory的回调。（回调和mandatory一起使用的情况下）。

## 10.其他知识点

### 10.1幂等性

用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。

[深入理解幂等性 - java懒洋洋 - 博客园 (cnblogs.com)](https://www.cnblogs.com/javalyy/p/8882144.html)

例如：

用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等

#### 消息重复消费

消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。

**解决思路**

MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费 者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。

**消费端的幂等性保障 **

在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现

**唯一ID+指纹码机制**

指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。

**Redis 原子性**

利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费

#### 优先级队列

官方文档：[优先级队列支持 - 兔子 (rabbitmq.com)](https://www.rabbitmq.com/priority.html)

![image-20210918223927996](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918223927996.png)

```java
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-max-priority", 10);
ch.queueDeclare("my-priority-queue", true, false, false, args);
```

流程：

1. 创建交换机
2. 创建队列，将队列设置为优先级队列    优先级范围0-255
3. 将队列与交换机绑定
4. 发送消息，发送消息时，设置消息的优先级

注意：

1. 优先级范围0-255.数据越大，优先级越高。
2. 发送消息的优先级，必须小于队列设置的最大优先级。

##### 生产者和消费者

**生产者**

```java
    @GetMapping("sendPriorityMsg3")
    public void sendPriorityMsg3() {
        //指定消息 id 为 1
        String routingKey = ConfirmQueueConfig.ROUTING_KEY;

        for (int a = 0; a < 10; a++) {
            if (a == 5) {
                log.info("发布一条：{}进入发布确认高级队列：{}", a, ConfirmQueueConfig.EXCHANGE_NAME);
                rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_NAME, routingKey , String.valueOf(a),args -> {
                    args.getMessageProperties().setPriority(10);
                    return args;
                }, new CorrelationData(UUID.randomUUID().toString()));
            } else {
                log.info("发布一条：{}进入发布确认高级队列：{}", a, ConfirmQueueConfig.EXCHANGE_NAME);
                rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_NAME, routingKey , String.valueOf(a),args -> {
                    args.getMessageProperties().setPriority(3);
                    return args;
                }, new CorrelationData(UUID.randomUUID().toString()));
            }
        }


    }
```

生产消息，设置消息等级为10

**消费者**

``` java
@Configuration
@Slf4j
public class ConfirmQueueConsumer {
    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_NAME)
    public void receiveConfirmQueue(Message message) {
        String msg = new String(message.getBody());
        log.info("当前时间：{},收到发布确认队列的消息：{}", new Date().toString(), msg);
    }

}

```

##### 创建队列和交换机

```java
  public static final String EXCHANGE_NAME = "confirm-exchange-1";
    public static final String QUEUE_NAME = "confirm-queue-1";
    public static final String ROUTING_KEY = "confirm-routingkey-1";

    @Bean("confirmExchange")
    public DirectExchange exchange1() {
        //普通交换机绑定备份交换机
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).withArgument("alternate-exchange", BACKUP_EXCHANGE).build();
    }

    @Bean("confirmQueue")
    public Queue queue1() {
       // 设置队列的优先级
        Map<String, Object> map = new HashMap<>();
        map.put("x-max-priority", 10);
        return new Queue(QUEUE_NAME, true, false, false, map);
//        return new Queue(QUEUE_NAME);
    }

    //普通交换机绑定普通队列
    @Bean
    public Binding bindExchange1ToQueue1(@Qualifier("confirmExchange") DirectExchange directExchange, @Qualifier("confirmQueue") Queue queue) {
        return BindingBuilder.bind(queue).to(directExchange).with(ROUTING_KEY);
    }

```



#####  结果

![image-20210919110408860](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919110408860.png)

我们发现5的优先级最高，所以5先进入消费者队列。

注意：测试时先将消费者关闭，因为消费者不关闭的情况下，消息是发送一条消费一条，看不到效果。



#### 惰性队列

惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。

![image-20210918224821479](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918224821479.png)

两种模式：默认和lazy

惰性队列，将信息存储在磁盘上，内存中只存消息的key，极大地减少了内存的占用空间。

使用场景：消息大量，且消费者挂掉，导致内存中存在大量消息

缺点：消费消息慢。

配置方式：创建队列时设置或者通过Policy设置。

```java
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-queue-mode", "lazy");
channel.queueDeclare("myqueue", false, false, false, args);
```

```java
    @Bean("confirmQueue")
    public Queue queue1() {
       // 设置队列的优先级
        Map<String, Object> map = new HashMap<>();
        map.put("x-max-priority", 10);
        //设置队列为惰性队列。
        map.put("x-queue-mode","lazy");
        return new Queue(QUEUE_NAME, true, false, false, map);
//        return new Queue(QUEUE_NAME);
    }
```



## 11.集群原理(没有学习)

![image-20210918225720555](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210918225720555.png)





## 12.API参考

### 队列

#### 创建队列时，可传入的参数

![image-20210917143243638](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210917143243638.png)

## 13. 常见问题汇总

### 13.1 15672和5672

15672:mq管理平台的页面端口

5672：mq服务的端口

[RabbitMQ的15672和5672端口](https://www.cnblogs.com/jiex123/p/12826989.html)

### 重置RabbitMq

1. 首先定位到 rabbitMQ 安装目录的sbin 目录下。打开cmd窗口。
2. 关闭应用的命令为： rabbitmqctl stop_app
3. 清除的命令为： rabbitmqctl reset
4. 重新启动命令为： rabbitmqctl start_app

查看所有队列命令： rabbitmqctl list_queues

查看所有交换机命令： rabbitmqctl list_exchanges

# 思维导图

![rabbitmq (1)](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/rabbitmq%20(1).png)



