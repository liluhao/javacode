classloader:类加载器
javaclass:字节码文件（1个类从源代码编译成字节码文件）
类都是放在方法区的地方，类将来创建的实例对象都是放在堆里，堆里面的对象在调用方法时又会用到虚拟机栈和程序计数器和本地方法栈
方法执行时每行代码是由解释器逐行进行执行，方法里的“热点代码”（被频道调用的代码）会由即时编译器优化执行，GC垃圾回收会对堆里不再引用的对象进行垃圾回收
还有一些java代码不方便实现的功能，必须调用底层操作系统的功能，用本地接口来调用

PrintStream out=System.out
把system.out赋值给了PrintSream变量
通过这个变量调用system对象的prinln方法
java源代码：键盘敲的那些，不能被直接执行，需要经过编译行程二进制字节码
二进制字节码（是一种二进制指令，但不是机器指令，是java虚拟机可识别的指令）：即0：getstaic    #20；3 astore v_1 （0是指令对应的内存地址，在字节码中就已经有了，当这些指令被加载到内存地址后，再被转化为特殊的地址信息，根据这些地址信息就可以找到这条命令来执行它）（执行流程：拿到getstaic指令，交给解释器，变成机器码，交给cpu运行；与此同时，就把3放到程序计数器，解释器就会到3去取下一条指令） 这一整行的jvm指令，在windos苹果上通用，这些指令不能交给cpu来执行，必须经过一个解释器，解释器是是jqva虚拟机的一个组件，它负责把指令转换为机器码，机器码就可以交给cpu，cpu来执行。
寄存器是程序计数器，在java虚拟机中是执行速度最快的
多线程：一条线上，有时间片，不同代码来回切换
每个线程都有属于自己的程序计数器
内存溢出：程序运行要用到的内存大于虚拟机能提供的最大内存
java中每个线程运行时需要给每个线程划分一个内存空间，即一个线程运行需要一个虚拟机栈，如果多个线程的话需要多个虚拟机栈，一个栈由多个栈帧构成，即将来要放进去的元素，一次栈帧就是一次方法的调用
线程最重是要去执行代码的，这些代码又是由一个个方法构成的;线程运行的时候，每个方法它需要的内存就称之为一个栈帧；
方法运行时候需要的内存：参数，局部变量，返回地址，这都在栈帧中
一个栈中是可以有多个栈帧的，比如方法1调用了方法2，方法二会产生新的栈帧，放进去栈中，产生栈帧内存；方法二调用结束后，栈帧二的内存释放掉，方法1调用结束后，栈帧1的内存释放掉

idea中左下角运行后的frames就代表着虚拟机栈；frames中最顶部的就是活动栈帧
main方法也算一个栈帧
idea中栈的演示：点击代码左侧的空白处，产生断电，右击绿色以debug的方式
Variables:栈帧内变量

垃圾回收不涉及栈内存，因为栈帧方法每一次调用完后都会自动被回收掉的；垃圾回收只回收堆内存中的无用对象，栈内存不需要垃圾回收的处理

-Xss size
设置栈内存的大小，设置的栈的大小决定了函数调用的最大深度
-Xss 设置的大小决定了函数调用的深度，如果函数调用的深度大于设置的Xss大小，那么将抛“java.lang.StackOverflowError“ 异常

1024KB是1兆   1兆=1MB=1兆字节
栈划分xxs栈内存越大，不会是运行的越快，反而使线程数运行的越少。所以一般不建议设置过大的栈内存，一般采用系统默认的即可
windos xss size:根据windos的虚拟内存影响每个栈的大小
方法内使用 new Thread()就是在方法内创建一个新的线程

线程的概念：
线程是程序最基本的运行单位，而进程不能运行，所以能运行的，是进程中的线程。
线程是如何创建起来的：
进程仅仅是一个容器，包含了线程运行中所需要的数据结构等信息。一个进程创建时，操作系统会创建一个线程，这就是主线程，而其他的从线程，却要主线程的代码来创建，也就是由程序员来创建。
当一个程序启动时，就有一个进程被操作系统(OS)创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程(Main Thread)，因为它是程序开始时就执行的，如果你需要再创建线程，那么创建的线程就是这个主线程的子线程。每个进程至少都有一个主线程，在Winform中，应该就是创建GUI的线程。  主线程的重要性体现在两方面：1.是产生其他子线程的线程；2.通常它必须最后完成执行比如执行各种关闭动作。
究竟main函数是进程还是线程呢：
因为它们都是以main()做为入口开始运行的。　是一个线程,同时还是一个进程。在现在的操作系统中，都是多线程的。但是它执行的时候对外来说就是一个独立的进程。这个进程中，可以包含多个线程，也可以只包含一个线程。当用c写一段程序的话，就是在操作系统中起一个进程它包含一个线程。而当用java等开发一个多线程的程序的话，它在操作系统中起了一个进程，但它可以包含多个同时运行的线程。

栈内存溢出
1栈帧过多：方法的递归调用没有设置一个正常的结束条件，自己不断的调用自己，栈帧不断的增加，会导致栈的溢出
2栈帧过大：一般很少出现，正常的一个栈1024MB（1024*1024个字节），一般一个方法内的变量都很少且很小，int才4个字节，用不完

java.lang.stackoverflowerror栈内存溢出
第三方的库也会导致栈内存溢出（两个类循环引用）
@JsonIgnore下面的会进行中断

线程运行诊断：:
    1.cpu占用过多：一个应用程序在运行时cpu占用居高不下，导致其他程序的运行受到影响
2.程序运行时间很长也没有结果


1.
liunx命令行中显示所有进程对cpu的使用和内存占用情况：top
top命令只能定位到进程，定位不到进程中的哪个线程对cpu的使用情况
pid是进程编号
tid是线程编号
liunx命令行中显示所有线程对cpu的占用：ps H eo pid,tid,%cpu(显示的结果：第一竖行是进程，第二竖行是线程，第三竖行是线程cpu使用百分比)
liunx命令行中显示进程32655中所有线程对cpu的占用：  
ps H eo pid,tid,%cpu  |  grep  32655
(显示的结果：第一竖行是32655进程，第二竖行是32655进程中的线程，第三竖行是线程cpu使用百分比)

用jdk提供的工具看是哪个线程出现问题了(也是在liunx中使用)
：jstack  进程id(jstack 32655)
（可以把32655进程中所有的java线程就出来，特殊英文单词的都是java虚拟机中自己固定的线程，但thread1、thread2都是用户自己定义的线程，即用户线程）（输出的id都是16进制，先把32655进程中的32665线程10进制的转换为16制的7F99）
定位后tid发现问题
Demo1_16.java:8 （意思是Demo1_16类的第八行代码出现了问题）
然后解决

    2.运行进程为32753java代码后不运行
然后输入以下： 
jstack  32753
发现原因可能是多个进程发生死锁
dead lock：死锁的意思
可以看到thread1与thread2发生了死锁
然后看具体原因在哪个类及哪个行
（视频中的死锁问题：新建2个a b对象，一个线程把a对象锁之后，另一个线程再去锁a对象;另一个线程已经锁b对象后，一个线程再想去锁b对象。此时两个线程会发生死锁;解决方法：必须得先把a对象释放了，才能继续去锁住a对象）
一个java类中是可以有多个线程的，也就是说一个类是可以作为一个进程的，比如在一个类中用new thread创建多个线程


本地方法：指不是由java代码编写的方法（因为java代码有一定的限制，有时候不能直接跟操作系统打交道，所以需要用c或者c++编写的本地方法来真正与操作系统底层的api打交道,java代码可以间接的使用本地方法来调用到底层的一些功能）
本地方法栈：
java虚拟机在调用本地方法时为本地方法提供的一个内存空间，本地方法运行的时候所使用的内存就是本地方法栈


典型的本地方法就是Object类中的方法，，比如clone（）方法等，功能是对象的克隆，由native声明，native生明的方法是没有方法实现的（在object类中只有一行声明方法的代码，该方法的代码没有大括号，都是由c或者c++编写的）
java代码间接的调用native方法，通过native本地方法的接口间接的去调用

程序计数器 虚拟机栈 本地方法栈 都是线程私有的
但是堆  方法区都是所有java虚拟机线程共享的区域

堆里有一个垃圾回收机制，堆中不被回收再引用的对象就会当成一个垃圾被回收以释放空闲的内存
堆内存耗尽问题：太多对象被引用，释放不掉
堆内存溢出英文：JAVA.lang.outofmemoryerror:java heap space


new创建的用的都是堆空间，数组也是
如果一个数组变量被设为null，则变量不会再引用刚刚的数组对象，即数组对象可以被垃圾回收了，调用gc方法进行垃圾回收
例如以下代码
创建对象；
变量名=null；
System.gc();

查看堆内存方法：用以下jmap命令，创建对象与回收对象分别看Eden Space的use与free会发生发生变化
在idea中进入终端命令行
查看进程id及进程对应名字（只有JAVA中的）：
jps
检查指定JAVA 进程（比如一个类中只有main方法，则但jps后既有main的进程id也有main所在类Demo01_4的进程id，则选中该类的id）的堆内存占用及堆的配置信息：
jmap -heap 18756

输入（输入后会弹出来一个图形化窗口，点击本地进程，选中Demo_4，点击连接，选择不安全连接，可以直观实时的看到堆内存的使用量，不用像jmap得一次一次看；跟之前jstack的功能一样，可以看死锁；点击内存，再点击执行GC可以进行垃圾回收，不过只能释放掉Ede Space，不能释放掉Ps old  generation,原因是对象一直在被引用，通过下面的jvisualvm）,n;这里面的单位比较特殊，Mb就是兆的意思）：
jconsole

打开可视化虚拟机，双击Demo01_13，点击监视，点击堆Dump,把那一时刻堆的信息给截取生成，并且这一时刻堆里面有哪一时刻堆里的对象及每个对象的个数，点击检查，设20，点查找，查前20名所占内存大小，再点击是，点击排名第一的，然后可以在字段里面一个个看，查找原因即可知道哪个对象出现问题，自己再去定位到代码，"保留"一列下面的数字即所占内存，默认单位是兆：
jvisualvm





fied是成员变量的意思
逻辑是方法区是堆的组成部分，但在方法区的实现上，不同厂商实现到底是不是堆的组成部分是不一样的




方法区也会导致虚拟机内存不足，抛出outmeoryerror
stringtable：串池/字符串表
jvm1.6内存结构是永久代（PermGen space)实现；
jvm1.8内存结构后废弃了 永久代实现，其中的元空间（MetaSpace)已经不占用堆内存，即已经不是由jvm内存管理，由本地操作系统内存管理，即元空间几乎没有内存上限，stringtable被放到了heap堆里

classloader类加载器可以用来加载类的二进制字节码
设置元空间内存
Voption：－XX：MaxMetaspaceSize=8m

classwriter对象是生成类的二进制字节码
元空间内存溢出英文：
outmeoryerror：MetaSpace
元空间内存溢出英文：
outmeoryerror：PermGen space
1.6jvm永久代空间溢出:加载了很多的类，产生了太多的字节码文件
1.8jvm导致元空间溢出：加载了很多的类，产生了太多的字节码文件

永久代回收效率低，元空间回收效率高
spring与mybatis在使用中会动态的生成很多类，造成溢出

二进制字节码（类的基本信息，常量池，类中的一些方法定义（虚拟机指令））

查看反编译class文件后的详细信息，指令在idea的终端里：
cd out中Helloworld.class所在文件的目录                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
javap －v  Helloworld.class
例如：
D:\all project\ideal project\heimastudy\heimastudy1\out\production\gitstudy\it\cast>javap -v Hello.class
下面可以看到一个类的常量池constant pool

localvariabletable：局部变量表
全局变量表：global variable table
所有的字符串在运行时只有遇到时才会被创建成字符串对象并被放进stringstable里，不遇到则不会被创建且不会被放进；
如果运行时再遇到相同的，则直接取串池里的就行，不用再放进

Memory 内存
Cache 缓存
stringtable是常量池的一部分，跟着常量池存在永久代当中
1.7和1.8之后string table转移到了堆中
原因是永久代的内存回收效率很地低


string table也会受到垃圾回收的管理的
当内存空间不足时，string Ta ble中那些没有被引用的字符串常量就会被垃圾回收
字符串常量并不是永久的


直接内存不受虚拟机管理，属于系统，占用的是操作系统内存
用于NIO操作，在NIO进行数据读写时，用做它的缓冲区内存
NIO里有个bytebuffer，bytebuffer所分配和使用的内存就是直接内存，不属于jvm虚拟机管理，属于操作系统内存，分配和收成本就比较高了速度慢些，因为他是属于操作系统，但是它的读写性能会非常的高
